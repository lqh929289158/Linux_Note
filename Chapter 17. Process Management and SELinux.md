# Chapter 17. Process Management and SELinux

# 1. What is Process?

In Linux, whenever an event is triggered, it will be defined as a process, and assign a **PID** to it. At the same time, the **authorities** will be bounded to the process according to the its **owner** and related configuration. Then, what the process can do is limited by its **autorities**.

## 1.1 Process and Program

Program: A binary **file** stored in storage device.
Process: A executing program loaded to **main memory** with a label **PID** and related **authorites, data, code** and so on.

The same program triggered by different users will become processes with different authorities.

### Child and Parent process

Child Process: process triggered by another process(Parent process).
Parent Process: A process which triggered another process(Child process).

Use `ps -l` to list all process.
The PID and PPID(Parent PID) will be listed.

### `fork` and `exec` the procedure of process call
We call Parent Process A and Chile Process B.
1. A(PID:x,Name:zzz)  `fork`-> TMP(PID:y, PPID:x, NAME:zzz)
2. A `exec qqq`-> B(PID:y, PPID:x, NAME:qqq)

### System/Network Service: Resident Process

The services always executing in the memory are called resident process, such as **crond**(scanning `/etc/crontab` per minute). They are also called **daemon**.

## 1.2 Multiple-User Multiple-Job Environment

In default, Linux has 7 login windows(Terminal)(6 command line and 1 GUI).Every terminal can be logged in by different users.

In Linux, it will never freeze! Because it can kill the dead process and restart it. What you need to do is switch to another termial by \[Alt\] + \[F1\]/\[F2\]... and `ps -aux` find the dead process and `kill` it!

How could we run many process simutaneously in single bash? Yes!
```
[root@www ~]# cp file1 file2 &
```
The `&` will execute the command in backend and you can start another sub-process.

# 2. Job Control

## 2.1 What is Job Control?

First, job control is a concept in one bash, where the processes are related to each other(a process tree?). So we can't manage bash of `tty2` from environment `tty1` by job control.

Second, **foreground** is the terminal you can see and interact. **Background** is a invisible environment where the processes are paused or executed.
> NOTE: Process in background **can't interact with users** and **can't be terminated by \[Ctrl\] + \[c\]**.

In summary:
- Job Control is about the sub-processes generated by your **bash**.(Limited in a bash)
- Foreground: Environment where you can control and execute commands.
- Background: Environment where processes are executed automatically. Can't be terminated by \[Ctrl\]+\[c\] but you can use bg/fg to call them.
- Processes run in the background can not wait for the input from foreground.

## 2.2 Job Control management

### Execute command in background `&`

```
[root@www ~]# tar -zpcf /tmp/etc.tar.gz /etc &
[1] 8400  <== [job number] PID 
[root@www ~]# tar: Removing leading `/' from member names 
# 在中括号内的号码为工作号码 (job number)，该号码与 bash 的控制有关。
# 后续的 8400 则是这个工作在系统中的 PID。至於后续出现的数据是 tar 运行的数据流，
# 由於我们没有加上数据流重导向，所以会影响画面！不过不会影响前景的操作喔！
```
The output(**stdout**, **stderr**) will still be printed on the foreground. But the task can not be killed by \[Ctrl\]+c.
The best way is to redirect the output.
```
[root@www ~]# tar -zpcvf /tmp/etc.tar.gz /etc > /tmp/log.txt 2>&1 &
[1] 8429
[root@www ~]# 
```
All output will be redirected to the file `/tmp/log.txt`.

### Stop the job temporarily and throw into background \[Ctrl\]+z

### Check background `jobs`

```
[root@www ~]# jobs [-lrs]
选项与参数：
-l  ：除了列出 job number 与命令串之外，同时列出 PID 的号码；
-r  ：仅列出正在背景 run 的工作；
-s  ：仅列出正在背景当中暂停 (stop) 的工作。

范例一：观察目前的 bash 当中，所有的工作，与对应的 PID
[root@www ~]# jobs -l
[1]- 10314 Stopped                 vim ~/.bashrc
[2]+ 10833 Stopped                 find / -print
```
The symbol `+` means the last job pushed into background.`-` is the last second job pushed into background. The others have no symbol. 

### Get the job back from background to foreground `fg`
```
[root@www ~]# fg %jobnumber
选项与参数：
%jobnumber ：jobnumber 为工作号码(数字)。注意，那个 % 是可有可无的！

范例一：先以 jobs 观察工作，再将工作取出：
[root@www ~]# jobs
[1]- 10314 Stopped                 vim ~/.bashrc
[2]+ 10833 Stopped                 find / -print
[root@www ~]# fg      <==默认取出那个 + 的工作，亦即 [2]。立即按下[ctrl]-z
[root@www ~]# fg %1   <==直接规定取出的那个工作号码！再按下[ctrl]-z
[root@www ~]# jobs
[1]+  Stopped                 vim ~/.bashrc
[2]-  Stopped                 find / -print
```
In default, `fg` will get the `+` job from background to foreground, unless you specify the PID.

### Continue the stopped job in background `bg`
```
范例一：一运行 find / -perm +7000 > /tmp/text.txt 后，立刻丢到背景去暂停！
[root@www ~]# find / -perm +7000 > /tmp/text.txt
# 此时，请立刻按下 [ctrl]-z 暂停！
[3]+  Stopped                 find / -perm +7000 > /tmp/text.txt

范例二：让该工作在背景下进行，并且观察他！！
[root@www ~]# jobs ; bg %3 ; jobs
[1]-  Stopped                 vim ~/.bashrc
[2]   Stopped                 find / -print
[3]+  Stopped                 find / -perm +7000 > /tmp/text.txt
[3]+ find / -perm +7000 > /tmp/text.txt &  <==用 bg%3 的情况！
[1]+  Stopped                 vim ~/.bashrc
[2]   Stopped                 find / -print
[3]-  Running                 find / -perm +7000 > /tmp/text.txt &
```

### `kill`

```
[root@www ~]# kill -signal %jobnumber
[root@www ~]# kill -l
选项与参数：
-l  ：这个是 L 的小写，列出目前 kill 能够使用的讯号 (signal) 有哪些？
signal ：代表给予后面接的那个工作什么样的指示罗！用 man 7 signal 可知：
  -1 ：重新读取一次参数的配置档 (类似 reload)；
  -2 ：代表与由键盘输入 [ctrl]-c 同样的动作；
  -9 ：立刻强制删除一个工作；
  -15：以正常的程序方式终止一项工作。与 -9 是不一样的。

范例一：找出目前的 bash 环境下的背景工作，并将该工作『强制删除』。
[root@www ~]# jobs
[1]+  Stopped                 vim ~/.bashrc
[2]   Stopped                 find / -print
[root@www ~]# kill -9 %2; jobs
[1]+  Stopped                 vim ~/.bashrc
[2]   Killed                  find / -print
# 再过几秒你再下达 jobs 一次，就会发现 2 号工作不见了！因为被移除了！

范例：找出目前的 bash 环境下的背景工作，并将该工作『正常终止』掉。
[root@www ~]# jobs
[1]+  Stopped                 vim ~/.bashrc
[root@www ~]# kill -SIGTERM %1
# -SIGTERM 与 -15 是一样的！您可以使用 kill -l 来查阅！
```

- `-9` is used to terminate an abnormal job.
- `-15` is used to terminate a job normally.

## 2.3 Offline Management

Problem: Suppose that you log in a host remotely, the jobs will be killed when you log out even if they are in background.

Why? Note that you log in with a terminal like `tty1`, `bg`,`&`,`fg` are just management about your **terminal**, not system background or foreground.

You can use `at` to put the jobs into system background despite of terminal. Or use `nohup`:

```
[root@www ~]# nohup [命令与参数]   <==在终端机前景中工作
[root@www ~]# nohup [命令与参数] & <==在终端机背景中工作

# 1. 先编辑一支会『睡著 500 秒』的程序：
[root@www ~]# vim sleep500.sh
#!/bin/bash
/bin/sleep 500s
/bin/echo "I have slept 500 seconds."

# 2. 丢到背景中去运行，并且立刻注销系统：
[root@www ~]# chmod a+x sleep500.sh
[root@www ~]# nohup ./sleep500.sh &
[1] 5074
[root@www ~]# nohup: appending output to ‘nohup.out’ <==会告知这个信息！
[root@www ~]# exit
```
> WARNING: `nohup` does **NOT** support built-in bash commands. So you have to use external commands(Specify the absolute path of commands).


# 3. Process Management

Motivations of process management:
- The execution rights are related to the PID of the process.
- How to find the allocation distribution of resources among the processes.
- How to find a problematic process in the memory.
- How to set priority of process

## 3.1 Observation

### `ps` print the processes now once.
```
[root@www ~]# ps aux  <==观察系统所有的程序数据
[root@www ~]# ps -lA  <==也是能够观察所有系统的数据
[root@www ~]# ps axjf <==连同部分程序树状态
选项与参数：
-A  ：所有的 process 均显示出来，与 -e 具有同样的效用；
-a  ：不与 terminal 有关的所有 process ；
-u  ：有效使用者 (effective user) 相关的 process ；
x   ：通常与 a 这个参数一起使用，可列出较完整资讯。
输出格式规划：
l   ：较长、较详细的将该 PID 的的资讯列出；
j   ：工作的格式 (jobs format)
-f  ：做一个更为完整的输出。
```
### (Usually used) Only process of my bash: `ps -l`
```
范例一：将目前属於您自己这次登陆的 PID 与相关资讯列示出来(只与自己的 bash 有关)
[root@www ~]# ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0 13639 13637  0  75   0 -  1287 wait   pts/1    00:00:00 bash
4 R     0 13700 13639  0  77   0 -  1101 -      pts/1    00:00:00 ps
```
- F: process flags(rights)
  - 4: root
  - 1: sub-process forked but not executed
- S: state
  - R: Running
  - S: Sleep can be awaked by signal
  - D: Sleep can't be awaked by signal (may be waiting for I/O)
  - T: Stopped. (Maybe stopped into background or traced)
  - Z: Zombie. Terminated but not removed from memory.
- UID/PID/PPID: User ID/Process ID/Parent Process ID.
- C: CPU occupation rate.
- PRI/NI: Priority/Nice. Smaller ones prior.
- ADDR/SZ/WCHAN: kernel function, the address of program in memory.(`-` for running)/Used Memory/Running or not (`-` for running)
- TTY: termial address. Dynamic terminal `pts/n` for remote login.
- TIME: Consumed CPU time. (The total CPU execution time, not the time how long the process in system!)
- CMD: command which trigger the process.
### Observe all system process: `ps aux`

```
范例二：列出目前所有的正在内存当中的程序：
[root@www ~]# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0   2064   616 ?        Ss   Mar11   0:01 init [5]
root         2  0.0  0.0      0     0 ?        S<   Mar11   0:00 [migration/0]
root         3  0.0  0.0      0     0 ?        SN   Mar11   0:00 [ksoftirqd/0]
.....(中间省略).....
root     13639  0.0  0.2   5148  1508 pts/1    Ss   11:44   0:00 -bash
root     14232  0.0  0.1   4452   876 pts/1    R+   15:52   0:00 ps aux
root     18593  0.0  0.0   2240   476 ?        Ss   Mar14   0:00 /usr/sbin/atd
```
- USER: Owner
- PID
- %CPU: Occupied CPU
- %MEM: Occupied Real Memory
- VSZ: Occupied Virtual Memory(KB)
- RSS: Occupied fixed Memory(KB)
- TTY: Run on which termial (`?` for no relation with terminal)
  - `tty1-tty6`
  - `pts/0`... login by network
- STAT: state(flag)
- START: Start time.
- TIME: CPU execution in real.
- COMMAND

Zombie process: The process should be terminated but the parent process can not allow it terminated for some reason. So the process will be left in the memory but will not be moved out unless `kill`. The label is `<defunct>`.
# 4. Special file and process

# 5. SELinux
