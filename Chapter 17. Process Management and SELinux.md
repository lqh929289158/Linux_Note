# Chapter 17. Process Management and SELinux

# 1. What is Process?

In Linux, whenever an event is triggered, it will be defined as a process, and assign a **PID** to it. At the same time, the **authorities** will be bounded to the process according to the its **owner** and related configuration. Then, what the process can do is limited by its **autorities**.

## 1.1 Process and Program

Program: A binary **file** stored in storage device.
Process: A executing program loaded to **main memory** with a label **PID** and related **authorites, data, code** and so on.

The same program triggered by different users will become processes with different authorities.

### Child and Parent process

Child Process: process triggered by another process(Parent process).
Parent Process: A process which triggered another process(Child process).

Use `ps -l` to list all process.
The PID and PPID(Parent PID) will be listed.

### `fork` and `exec` the procedure of process call
We call Parent Process A and Chile Process B.
1. A(PID:x,Name:zzz)  `fork`-> TMP(PID:y, PPID:x, NAME:zzz)
2. A `exec qqq`-> B(PID:y, PPID:x, NAME:qqq)

### System/Network Service: Resident Process

The services always executing in the memory are called resident process, such as **crond**(scanning `/etc/crontab` per minute). They are also called **daemon**.

## 1.2 Multiple-User Multiple-Job Environment

In default, Linux has 7 login windows(Terminal)(6 command line and 1 GUI).Every terminal can be logged in by different users.

In Linux, it will never freeze! Because it can kill the dead process and restart it. What you need to do is switch to another termial by \[Alt\] + \[F1\]/\[F2\]... and `ps -aux` find the dead process and `kill` it!

How could we run many process simutaneously in single bash? Yes!
```
[root@www ~]# cp file1 file2 &
```
The `&` will execute the command in backend and you can start another sub-process.

# 2. Job Control

## 2.1 What is Job Control?

First, job control is a concept in one bash, where the processes are related to each other(a process tree?). So we can't manage bash of `tty2` from environment `tty1` by job control.

Second, **foreground** is the terminal you can see and interact. **Background** is a invisible environment where the processes are paused or executed.
> NOTE: Process in background **can't interact with users** and **can't be terminated by \[Ctrl\] + \[c\]**.

In summary:
- Job Control is about the sub-processes generated by your **bash**.(Limited in a bash)
- Foreground: Environment where you can control and execute commands.
- Background: Environment where processes are executed automatically. Can't be terminated by \[Ctrl\]+\[c\] but you can use bg/fg to call them.
- Processes run in the background can not wait for the input from foreground.

## 2.2 Job Control management

### Execute command in background `&`

```
[root@www ~]# tar -zpcf /tmp/etc.tar.gz /etc &
[1] 8400  <== [job number] PID 
[root@www ~]# tar: Removing leading `/' from member names 
# 在中括号内的号码为工作号码 (job number)，该号码与 bash 的控制有关。
# 后续的 8400 则是这个工作在系统中的 PID。至於后续出现的数据是 tar 运行的数据流，
# 由於我们没有加上数据流重导向，所以会影响画面！不过不会影响前景的操作喔！
```
The output(**stdout**, **stderr**) will still be printed on the foreground. But the task can not be killed by \[Ctrl\]+c.
The best way is to redirect the output.
```
[root@www ~]# tar -zpcvf /tmp/etc.tar.gz /etc > /tmp/log.txt 2>&1 &
[1] 8429
[root@www ~]# 
```
All output will be redirected to the file `/tmp/log.txt`.

### Stop the job temporarily and throw into background \[Ctrl\]+z

### Check background `jobs`

```
[root@www ~]# jobs [-lrs]
选项与参数：
-l  ：除了列出 job number 与命令串之外，同时列出 PID 的号码；
-r  ：仅列出正在背景 run 的工作；
-s  ：仅列出正在背景当中暂停 (stop) 的工作。

范例一：观察目前的 bash 当中，所有的工作，与对应的 PID
[root@www ~]# jobs -l
[1]- 10314 Stopped                 vim ~/.bashrc
[2]+ 10833 Stopped                 find / -print
```
The symbol `+` means the last job pushed into background.`-` is the last second job pushed into background. The others have no symbol. 

### Get the job back from background to foreground `fg`
```
[root@www ~]# fg %jobnumber
选项与参数：
%jobnumber ：jobnumber 为工作号码(数字)。注意，那个 % 是可有可无的！

范例一：先以 jobs 观察工作，再将工作取出：
[root@www ~]# jobs
[1]- 10314 Stopped                 vim ~/.bashrc
[2]+ 10833 Stopped                 find / -print
[root@www ~]# fg      <==默认取出那个 + 的工作，亦即 [2]。立即按下[ctrl]-z
[root@www ~]# fg %1   <==直接规定取出的那个工作号码！再按下[ctrl]-z
[root@www ~]# jobs
[1]+  Stopped                 vim ~/.bashrc
[2]-  Stopped                 find / -print
```
In default, `fg` will get the `+` job from background to foreground, unless you specify the PID.

### Continue the stopped job in background `bg`
```
范例一：一运行 find / -perm +7000 > /tmp/text.txt 后，立刻丢到背景去暂停！
[root@www ~]# find / -perm +7000 > /tmp/text.txt
# 此时，请立刻按下 [ctrl]-z 暂停！
[3]+  Stopped                 find / -perm +7000 > /tmp/text.txt

范例二：让该工作在背景下进行，并且观察他！！
[root@www ~]# jobs ; bg %3 ; jobs
[1]-  Stopped                 vim ~/.bashrc
[2]   Stopped                 find / -print
[3]+  Stopped                 find / -perm +7000 > /tmp/text.txt
[3]+ find / -perm +7000 > /tmp/text.txt &  <==用 bg%3 的情况！
[1]+  Stopped                 vim ~/.bashrc
[2]   Stopped                 find / -print
[3]-  Running                 find / -perm +7000 > /tmp/text.txt &
```

### `kill`

```
[root@www ~]# kill -signal %jobnumber
[root@www ~]# kill -l
选项与参数：
-l  ：这个是 L 的小写，列出目前 kill 能够使用的讯号 (signal) 有哪些？
signal ：代表给予后面接的那个工作什么样的指示罗！用 man 7 signal 可知：
  -1 ：重新读取一次参数的配置档 (类似 reload)；
  -2 ：代表与由键盘输入 [ctrl]-c 同样的动作；
  -9 ：立刻强制删除一个工作；
  -15：以正常的程序方式终止一项工作。与 -9 是不一样的。

范例一：找出目前的 bash 环境下的背景工作，并将该工作『强制删除』。
[root@www ~]# jobs
[1]+  Stopped                 vim ~/.bashrc
[2]   Stopped                 find / -print
[root@www ~]# kill -9 %2; jobs
[1]+  Stopped                 vim ~/.bashrc
[2]   Killed                  find / -print
# 再过几秒你再下达 jobs 一次，就会发现 2 号工作不见了！因为被移除了！

范例：找出目前的 bash 环境下的背景工作，并将该工作『正常终止』掉。
[root@www ~]# jobs
[1]+  Stopped                 vim ~/.bashrc
[root@www ~]# kill -SIGTERM %1
# -SIGTERM 与 -15 是一样的！您可以使用 kill -l 来查阅！
```

- `-9` is used to terminate an abnormal job.
- `-15` is used to terminate a job normally.

## 2.3 Offline Management

Problem: Suppose that you log in a host remotely, the jobs will be killed when you log out even if they are in background.

Why? Note that you log in with a terminal like `tty1`, `bg`,`&`,`fg` are just management about your **terminal**, not system background or foreground.

You can use `at` to put the jobs into system background despite of terminal. Or use `nohup`:

```
[root@www ~]# nohup [命令与参数]   <==在终端机前景中工作
[root@www ~]# nohup [命令与参数] & <==在终端机背景中工作

# 1. 先编辑一支会『睡著 500 秒』的程序：
[root@www ~]# vim sleep500.sh
#!/bin/bash
/bin/sleep 500s
/bin/echo "I have slept 500 seconds."

# 2. 丢到背景中去运行，并且立刻注销系统：
[root@www ~]# chmod a+x sleep500.sh
[root@www ~]# nohup ./sleep500.sh &
[1] 5074
[root@www ~]# nohup: appending output to ‘nohup.out’ <==会告知这个信息！
[root@www ~]# exit
```
> WARNING: `nohup` does **NOT** support built-in bash commands. So you have to use external commands(Specify the absolute path of commands).


# 3. Process Management

Motivations of process management:
- The execution rights are related to the PID of the process.
- How to find the allocation distribution of resources among the processes.
- How to find a problematic process in the memory.
- How to set priority of process

## 3.1 Observation

### `ps` print the processes now once.
```
[root@www ~]# ps aux  <==观察系统所有的程序数据
[root@www ~]# ps -lA  <==也是能够观察所有系统的数据
[root@www ~]# ps axjf <==连同部分程序树状态
选项与参数：
-A  ：所有的 process 均显示出来，与 -e 具有同样的效用；
-a  ：不与 terminal 有关的所有 process ；
-u  ：有效使用者 (effective user) 相关的 process ；
x   ：通常与 a 这个参数一起使用，可列出较完整资讯。
输出格式规划：
l   ：较长、较详细的将该 PID 的的资讯列出；
j   ：工作的格式 (jobs format)
-f  ：做一个更为完整的输出。
```
### (Usually used) Only process of my bash: `ps -l`
```
范例一：将目前属於您自己这次登陆的 PID 与相关资讯列示出来(只与自己的 bash 有关)
[root@www ~]# ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0 13639 13637  0  75   0 -  1287 wait   pts/1    00:00:00 bash
4 R     0 13700 13639  0  77   0 -  1101 -      pts/1    00:00:00 ps
```
- F: process flags(rights)
  - 4: root
  - 1: sub-process forked but not executed
- S: state
  - R: Running
  - S: Sleep can be awaked by signal
  - D: Sleep can't be awaked by signal (may be waiting for I/O)
  - T: Stopped. (Maybe stopped into background or traced)
  - Z: Zombie. Terminated but not removed from memory.
- UID/PID/PPID: User ID/Process ID/Parent Process ID.
- C: CPU occupation rate.
- PRI/NI: Priority/Nice. Smaller ones prior.
- ADDR/SZ/WCHAN: kernel function, the address of program in memory.(`-` for running)/Used Memory/Running or not (`-` for running)
- TTY: termial address. Dynamic terminal `pts/n` for remote login.
- TIME: Consumed CPU time. (The total CPU execution time, not the time how long the process in system!)
- CMD: command which trigger the process.
### Observe all system process: `ps aux`

```
范例二：列出目前所有的正在内存当中的程序：
[root@www ~]# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0   2064   616 ?        Ss   Mar11   0:01 init [5]
root         2  0.0  0.0      0     0 ?        S<   Mar11   0:00 [migration/0]
root         3  0.0  0.0      0     0 ?        SN   Mar11   0:00 [ksoftirqd/0]
.....(中间省略).....
root     13639  0.0  0.2   5148  1508 pts/1    Ss   11:44   0:00 -bash
root     14232  0.0  0.1   4452   876 pts/1    R+   15:52   0:00 ps aux
root     18593  0.0  0.0   2240   476 ?        Ss   Mar14   0:00 /usr/sbin/atd
```
- USER: Owner
- PID
- %CPU: Occupied CPU
- %MEM: Occupied Real Memory
- VSZ: Occupied Virtual Memory(KB)
- RSS: Occupied fixed Memory(KB)
- TTY: Run on which termial (`?` for no relation with terminal)
  - `tty1-tty6`
  - `pts/0`... login by network
- STAT: state(flag)
- START: Start time.
- TIME: CPU execution in real.
- COMMAND

Zombie process: The process should be terminated but the parent process can not allow it terminated for some reason. So the process will be left in the memory but will not be moved out unless `kill`. The label is `<defunct>`.

### `top` dynamic process observation

```
[root@www ~]# top [-d 数字] | top [-bnp]
选项与参数：
-d  ：后面可以接秒数，就是整个程序画面升级的秒数。默认是 5 秒；
-b  ：以批量的方式运行 top ，还有更多的参数可以使用喔！
      通常会搭配数据流重导向来将批量的结果输出成为文件。
-n  ：与 -b 搭配，意义是，需要进行几次 top 的输出结果。
-p  ：指定某些个 PID 来进行观察监测而已。
在 top 运行过程当中可以使用的按键命令：
	? ：显示在 top 当中可以输入的按键命令；
	P ：以 CPU 的使用资源排序显示；
	M ：以 Memory 的使用资源排序显示；
	N ：以 PID 来排序喔！
	T ：由该 Process 使用的 CPU 时间累积 (TIME+) 排序。
	k ：给予某个 PID 一个讯号  (signal)
	r ：给予某个 PID 重新制订一个 nice 值。
	q ：离开 top 软件的按键。
```
```
范例一：每两秒钟升级一次 top ，观察整体资讯：
[root@www ~]# top -d 2
top - 17:03:09 up 7 days, 16:16,  1 user,  load average: 0.00, 0.00, 0.00
Tasks:  80 total,   1 running,  79 sleeping,   0 stopped,   0 zombie
Cpu(s):  0.5%us,  0.5%sy,  0.0%ni, 99.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:    742664k total,   681672k used,    60992k free,   125336k buffers
Swap:  1020088k total,       28k used,  1020060k free,   311156k cached
    <==如果加入 k 或 r 时，就会有相关的字样出现在这里喔！
  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND     
14398 root      15   0  2188 1012  816 R  0.5  0.1   0:00.05 top
    1 root      15   0  2064  616  528 S  0.0  0.1   0:01.38 init
    2 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 migration/0
    3 root      34  19     0    0    0 S  0.0  0.0   0:00.00 ksoftirqd/0
```
- Line 1: top,current time, execution time, login users, average load
- Line 2: Tasks, total, running, sleeping, stopped, zombie
- Line 3: Cpus
- Line 4: Physical Memory
- Line 5: Virtual Memory(Swap)
- States of Processes:
  - PID,USER
  - PR(Priority), NI(Nice)
  - %CPU, %MEM
  - TIME+: Total CPU time.
> NOTE: Usually used command: Press `P` in top to sort by CPU forcely.

### `pstree`
```
[root@www ~]# pstree [-A|U] [-up]
选项与参数：
-A  ：各程序树之间的连接以 ASCII 字节来连接；
-U  ：各程序树之间的连接以万国码的字节来连接。在某些终端介面下可能会有错误；
-p  ：并同时列出每个 process 的 PID；
-u  ：并同时列出每个 process 的所属帐号名称。

范例一：列出目前系统上面所有的程序树的相关性：
[root@www ~]# pstree -A
init-+-acpid
     |-atd
     |-auditd-+-audispd---{audispd}  <==这行与底下一行为 auditd 分出来的子程序
     |        `-{auditd}
     |-automount---4*[{automount}]   <==默认情况下，相似的程序会以数字显示
....(中间省略)....
     |-sshd---sshd---bash---pstree   <==就是我们命令运行的那个相依性！
....(底下省略)....
# 注意一下，为了节省版面，所以鸟哥已经删去很多程序了！

范例二：承上题，同时秀出 PID 与 users 
[root@www ~]# pstree -Aup
init(1)-+-acpid(4555)
        |-atd(18593)
        |-auditd(4256)-+-audispd(4258)---{audispd}(4261)
        |              `-{auditd}(4257)
        |-automount(4536)-+-{automount}(4537) <==程序相似但 PID 不同！
        |                 |-{automount}(4538)
        |                 |-{automount}(4541)
        |                 `-{automount}(4544)
....(中间省略)....
        |-sshd(4586)---sshd(16903)---bash(16905)---pstree(16967)
....(中间省略)....
        |-xfs(4692,xfs)   <==因为此程序拥有者并非运行 pstree 者！所以列出帐号
....(底下省略)....
# 在括号 () 内的即是 PID 以及该程序的 owner 喔！不过，由於我是使用 
# root 的身份运行此一命令，所以属於 root 的程序就不会显示出来啦
```

## 3.2 Management 

Method: By **signal**.

Usually used signal:
- #1 **SIGHUP**: Start the stopped process and reload the configuration and restart.
- #2 **SIGINT**: Stop the process by `[Ctrl]+c`
- #9 **SIGKILL**: Stop the process forcely and maybe some files remains.
- #15 **SIGTERM**: Terminate a process normally.(But can't used to terminate problematic process)
- #17 **SIGSTOP**: Stop the process by `[Ctrl]+z`

### `kill -signal PID`
### `killall -signal CMD`

## 3.3 Priority

### Priority and Nice

Priority: Modified by **kernel** dynamically not user.
Nice:Modified by user to influence priority.

> NOTE: 
> 1. PRI(new) = PRI(old) + nice. But it is not actually as this. The priority must be analyized by the kernel.
> 2. The range of nice is between **-20 ~ 19**.
> 3. **root** can modify the nice of **any** process. Range **-20 ~ 19**.
> 4. The range of nice the user can set is between **0 ~ 19**.
> 5. The user can only set **higher** nice than now.

### `nice` command to set process nice initially.
```
[root@www ~]# nice [-n 数字] command
选项与参数：
-n  ：后面接一个数值，数值的范围 -20 ~ 19。

范例一：用 root 给一个 nice 值为 -5 ，用於运行 vi ，并观察该程序！
[root@www ~]# nice -n -5 vi &
[1] 18676
[root@www ~]# ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0 18625 18623  0  75   0 -  1514 wait   pts/1    00:00:00 bash
4 T     0 18676 18625  0  72  -5 -  1242 finish pts/1    00:00:00 vi
4 R     0 18678 18625  0  77   0 -  1101 -      pts/1    00:00:00 ps
# 原本的 bash PRI 为 75  ，所以 vi 默认应为 75。不过由於给予 nice  为 -5 
```

### `renice` modify nice value.
```
[root@www ~]# renice [number] PID
选项与参数：
PID ：某个程序的 ID 啊！

范例一：找出自己的 bash PID ，并将该 PID 的 nice 调整到 10
[root@www ~]# ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0 18625 18623  0  75   0 -  1514 wait   pts/1    00:00:00 bash
4 R     0 18712 18625  0  77   0 -  1102 -      pts/1    00:00:00 ps

[root@www ~]# renice 10 18625
18625: old priority 0, new priority 10

[root@www ~]# ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0 18625 18623  0  85  10 -  1514 wait   pts/1    00:00:00 bash
4 R     0 18715 18625  0  87  10 -  1102 -      pts/1    00:00:00 ps
```

> NOTE: The nice value will be inheritted by the child process.

# 4. Special file and process

# 5. SELinux
